
שאלה 2 
נשים לב כי כתובת הכניסה של הפונקציה הוא ב 0x804816c ואילו כתובת הmain הוא ב 08048156 וזה לא טוב כי אנחנו רוצים שהם יהיו בעלי אותו ערך
נריץ את הפקודה readelf -s deep_thought ונראה כי בשורה של symbol table (symtbl) היא ב אופסט של 208
ובנוסף נשים לב כי בטבלה הזו הלייבל _start הוא הלייבל השמיני 
הגודל של לייבל הוא 16 ביטים ולכן נרצה לדלג אליו , כלומר נדלג 16*8 ביטים = 128 בבסיס אקסה = 80 בבסיס דצימלי
כלומר נרצה לקפוץ 208+80=288 ביטים 
אך נשים לב שאנו צריכים לדלג עוד 4 ביטים כדי לעבור את הכתובת הזו ( גודל של כתובת היא 4 ביטים ) ולכן נדלג בעצם 288+4 = 28C ביטים 
ומשם נקרא 4 ביטים ולכן נריץ את הפקודה 3 וניתן ערכים 28C ו 4 כדי לטעון את הכתובת לזיכרון
כאשר נבדוק בקובץ pdf של elf נראה כי כתובת הכניסה היא ב 0x18 ולכן נטען לשם את הכתובת ששמרנו בזיכרון 
 ולכן נריץ פקודה 6 וניתן ערכים 4 18 0 בתור <source-address> <target-location> <length>
 
 דרך אחרת לפתור את הבעיה היא להכניס בפקודה 7 את הכתובת 18 ואת הכתובת של _start
 בצורה הזו נשים בקובץ את המיקום של המיין וישר נקפוץ אליו שניכנס לפונקציה
 
 שאלה 3
 כדי למצוא את האופסט של פונקציה בתוך קובץ elf בהינתן הכתובת הוירטואלית של הפונקציה והאופסט של הקובץ 
 ב section שבו הפונקציה נמצאת נשתמש בנוסחא הבאה :
 file_offset= section_file_offset+(function_virtual_address- section_virtual_address) 
 נשתמש בנוסחא הזו כדי למצוא את האופסט של הפונקציה main
 נריץ את הפקודה readelf -s offensive 
 נחפש את הפונקציה main ונגלה כי הכתובת של הפונקציה היא 0804841d והגודל של הפונקציה היא 23
 בנוסף נשים לב כי בטבלת הסמלים הקוד מופיע ב section 13 בכתובת 08048320 והאופסט הוא 000320
 נציב את הנתונים בנוסחא ונקבל :
 file_offset = 000320 + 0804841d - 08048320 = 41d
 אנו רוצים לא לבצא את הפקודה שבמיין ולכן נכניס את הNOP בשורה הראשונה בפונקציה main
 ולכן נבצע את השלבים הבאים בהפעלה של הקוד hexaditplus
 1 -> offensive
 2 -> 1
 3 -> 41d 23
 7 -> 0 c3 (we load c3 becuase its equal to a return statement)
 6 -> 0 41d 23
 8
 אחרי שנבצע את השלבים האלה שנפעיל את offensive לא נקבל כלום ( כי בעצם איך שנכנסים למיין פוגשים 
 בפקודת return )
 
 שאלה 4 
